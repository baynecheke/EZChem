<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Molecule Sketchpad V6 (Grid System)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            background-color: #f3f4f6;
        }
        canvas {
            touch-action: none;
            /* No cursor, we will draw our own */
            cursor: none; 
            display: block;
            background-color: #ffffff;
        }
        .tool-btn.active {
            @apply bg-indigo-600 text-white shadow-inner;
        }
        .tool-btn:not(.active) {
            @apply hover:bg-gray-200;
        }
        #search-results::-webkit-scrollbar { display: none; }
        #search-results { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="h-full flex flex-col antialiased">

    <!-- Header Bar (Unchanged) -->
    <div class="bg-gray-800 text-white p-2 shadow-md flex items-center gap-4">
        <h1 class="text-xl font-bold text-center">EZChem</h1>
        <div class="relative flex-1 max-w-md mx-auto">
            <div class="flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="absolute left-3 top-1/2 -translate-y-1/2 size-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
                <input type="search" id="search-input" placeholder="Search atoms (e.g., 'Iron', 'Fe', '26')" class="w-full pl-10 pr-4 py-2 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500">
            </div>
            <div id="search-results" class="absolute z-50 w-full bg-white text-black rounded-lg shadow-lg mt-1 max-h-60 overflow-y-auto hidden">
                </div>
        </div>
    </div>

    <div class="flex-1 flex flex-row p-4 gap-4 h-full min-h-0">

        <!-- Toolbar (Unchanged) -->
        <div class="flex flex-col items-center bg-white p-2 rounded-lg shadow-lg gap-2 w-20">
            <h2 class="text-sm font-semibold text-center text-gray-600">Atoms</h2>
            
            <button id="tool-C" class="tool-btn active w-full h-16 rounded-lg font-bold text-2xl bg-gray-100 text-gray-800 shadow-md" data-atom="C">C</button>
            <button id="tool-H" class="tool-btn w-full h-16 rounded-lg font-bold text-2xl bg-gray-100 text-gray-800 shadow-md" data-atom="H">H</button>
            <button id="tool-O" class="tool-btn w-full h-16 rounded-lg font-bold text-2xl bg-gray-100 text-gray-800 shadow-md" data-atom="O">O</button>
            <button id="tool-N" class="tool-btn w-full h-16 rounded-lg font-bold text-2xl bg-gray-100 text-gray-800 shadow-md" data-atom="N">N</button>
            
            <div class="w-full border-t border-gray-200 my-2"></div>
            <h2 class="text-sm font-semibold text-center text-gray-600">Actions</h2>

            <button id="tool-group" class="tool-btn w-full h-16 rounded-lg bg-purple-500 text-white p-2 shadow-md flex items-center justify-center" title="Group Tool (Drag to create molecule box)">
                <svg xmlns="http://www.w3.org/2000/svg" class="size-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21 7.5l-9-5.25L3 7.5m18 0l-9 5.25m9-5.25v9l-9 5.25M3 7.5l9 5.25M3 7.5v9l9 5.25m0-9v9" />
                </svg>
            </button>

            <button id="tool-info" class="tool-btn w-full h-16 rounded-lg bg-blue-500 text-white p-2 shadow-md flex items-center justify-center" title="Info Tool (Click Atoms or Groups)">
                <svg xmlns="http://www.w3.org/2000/svg" class="size-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </button>

            <button id="tool-predict" class="tool-btn relative w-full h-16 rounded-lg bg-green-500 text-white p-2 shadow-md flex items-center justify-center" title="Predict Bonds (within groups)">
                <svg xmlns="http://www.w3.org/2000/svg" class="size-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707m12.728 0l-.707.707M12 21v-1m0-10c-1.657 0-3 2.239-3 5s1.343 5 3 5 3-2.239 3-5-1.343-5-3-5z" />
                </svg>
                <div id="loading-spinner" class="absolute inset-0 bg-green-500 bg-opacity-80 flex items-center justify-center rounded-lg hidden">
                    <svg class="animate-spin size-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
            </button>
            
            <button id="tool-clear" class="tool-btn w-full h-16 rounded-lg bg-red-500 text-white p-2 shadow-md flex items-center justify-center" title="Clear Canvas">
                <svg xmlns="http://www.w3.org/2000/svg" class="size-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            </button>
        </div>

        <!-- Canvas Area -->
        <div class="flex-1 bg-white rounded-lg shadow-lg h-full overflow-hidden">
            <canvas id="sketchpad"></canvas>
        </div>

    </div>

    <!-- Modals (Unchanged) -->
    <div id="message-box" class="fixed top-5 right-5 bg-red-500 text-white p-4 rounded-lg shadow-xl hidden z-50">
        <span id="message-text"></span>
    </div>

    <div id="atom-info-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-40 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold" id="modal-atom-name">Element Info</h2>
                <button id="modal-close-btn" class="text-gray-500 hover:text-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" class="size-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="space-y-2">
                <p><strong>Atom ID:</strong> <span id="modal-atom-id"></span></p>
                <p><strong>Element:</strong> <span id="modal-atom-element"></span></p>
                <p><strong>Grid Cell:</strong> <span id="modal-atom-grid"></span></p>
                <p><strong>Bonds:</strong> <span id="modal-atom-bonds"></span></p>
            </div>
            <div class="mt-4 pt-4 border-t">
                <h3 class="font-semibold mb-2">Fun Fact</h3>
                <div id="modal-fun-fact-box" class="bg-gray-100 p-3 rounded-lg min-h-[6rem] text-gray-700 italic">
                    <span id="modal-fun-fact-text">Click the button to get a fun fact!</span>
                </div>
                <button id="modal-fun-fact-btn" class="w-full bg-indigo-600 text-white p-2 rounded-lg mt-3 hover:bg-indigo-700">
                    Get Fun Fact
                </button>
            </div>
        </div>
    </div>

    <div id="group-info-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-40 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Molecule Info</h2>
                <button id="group-modal-close-btn" class="text-gray-500 hover:text-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" class="size-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="space-y-2">
                <p><strong>Formula:</strong> <span id="modal-group-formula"></span></p>
                <p><strong>Common Name:</strong> <span id="modal-group-name">N/A</span></p>
                <p><strong>Molar Mass:</strong> <span id="modal-group-mass">N/A</span></p>
            </div>
            <div class="mt-4 pt-4 border-t">
                <div id="modal-group-info-box" class="bg-gray-100 p-3 rounded-lg min-h-[4rem] text-gray-700 italic">
                    <span id="modal-group-info-text">Click the button to get AI-powered info.</span>
                </div>
                <button id="modal-group-info-btn" class="w-full bg-indigo-600 text-white p-2 rounded-lg mt-3 hover:bg-indigo-700">
                    Get AI Info (Name, Mass)
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Periodic Table Data (1-100) ---
        const PERIODIC_TABLE = [
            { n: 1, s: "H", name: "Hydrogen" }, { n: 2, s: "He", name: "Helium" }, { n: 3, s: "Li", name: "Lithium" }, { n: 4, s: "Be", name: "Beryllium" },
            { n: 5, s: "B", name: "Boron" }, { n: 6, s: "C", name: "Carbon" }, { n: 7, s: "N", name: "Nitrogen" }, { n: 8, s: "O", name: "Oxygen" },
            { n: 9, s: "F", name: "Fluorine" }, { n: 10, s: "Ne", name: "Neon" }, { n: 11, s: "Na", name: "Sodium" }, { n: 12, s: "Mg", name: "Magnesium" },
            { n: 13, s: "Al", name: "Aluminum" }, { n: 14, s: "Si", name: "Silicon" }, { n: 15, s: "P", name: "Phosphorus" }, { n: 16, s: "S", name: "Sulfur" },
            { n: 17, s: "Cl", name: "Chlorine" }, { n: 18, s: "Ar", name: "Argon" }, { n: 19, s: "K", name: "Potassium" }, { n: 20, s: "Ca", name: "Calcium" },
            { n: 21, s: "Sc", name: "Scandium" }, { n: 22, s: "Ti", name: "Titanium" }, { n: 23, s: "V", name: "Vanadium" }, { n: 24, s: "Cr", name: "Chromium" },
            { n: 25, s: "Mn", name: "Manganese" }, { n: 26, s: "Fe", name: "Iron" }, { n: 27, s: "Co", name: "Cobalt" }, { n: 28, s: "Ni", name: "Nickel" },
            { n: 29, s: "Cu", name: "Copper" }, { n: 30, s: "Zn", name: "Zinc" }, { n: 31, s: "Ga", name: "Gallium" }, { n: 32, s: "Ge", name: "Germanium" },
            { n: 33, s: "As", name: "Arsenic" }, { n: 34, s: "Se", name: "Selenium" }, { n: 35, s: "Br", name: "Bromine" }, { n: 36, s: "Kr", name: "Krypton" },
            { n: 37, s: "Rb", name: "Rubidium" }, { n: 38, s: "Sr", name: "Strontium" }, { n: 39, s: "Y", name: "Yttrium" }, { n: 40, s: "Zr", name: "Zirconium" },
            { n: 41, s: "Nb", name: "Niobium" }, { n: 42, s: "Mo", name: "Molybdenum" }, { n: 43, s: "Tc", name: "Technetium" }, { n: 44, s: "Ru", name: "Ruthenium" },
            { n: 45, s: "Rh", name: "Rhodium" }, { n: 46, s: "Pd", name: "Palladium" }, { n: 47, s: "Ag", name: "Silver" }, { n: 48, s: "Cd", name: "Cadmium" },
            { n: 49, s: "In", name: "Indium" }, { n: 50, s: "Sn", name: "Tin" }, { n: 51, s: "Sb", name: "Antimony" }, { n: 52, s: "Te", name: "Tellurium" },
            { n: 53, s: "I", name: "Iodine" }, { n: 54, s: "Xe", name: "Xenon" }, { n: 55, s: "Cs", name: "Caesium" }, { n: 56, s: "Ba", name: "Barium" },
            { n: 57, s: "La", name: "Lanthanum" }, { n: 58, s: "Ce", name: "Cerium" }, { n: 59, s: "Pr", name: "Praseodymium" }, { n: 60, s: "Nd", name: "Neodymium" },
            { n: 61, s: "Pm", name: "Promethium" }, { n: 62, s: "Sm", name: "Samarium" }, { n: 63, s: "Eu", name: "Europium" }, { n: 64, s: "Gd", name: "Gadolinium" },
            { n: 65, s: "Tb", name: "Terbium" }, { n: 66, s: "Dy", name: "Dysproslum" }, { n: 67, s: "Ho", name: "Holmium" }, { n: 68, s: "Er", name: "Erbium" },
            { n: 69, s: "Tm", name: "Thulium" }, { n: 70, s: "Yb", name: "Ytterbium" }, { n: 71, s: "Lu", name: "Lutetium" }, { n: 72, s: "Hf", name: "Hafnium" },
            { n: 73, s: "Ta", name: "Tantalum" }, { n: 74, s: "W", name: "Tungsten" }, { n: 75, s: "Re", name: "Rhenium" }, { n: 76, s: "Os", name: "Osmium" },
            { n: 77, s: "Ir", name: "Iridium" }, { n: 78, s: "Pt", name: "Platinum" }, { n: 79, s: "Au", name: "Gold" }, { n: 80, s: "Hg", name: "Mercury" },
            { n: 81, s: "Tl", name: "Thallium" }, { n: 82, s: "Pb", name: "Lead" }, { n: 83, s: "Bi", name: "Bismuth" }, { n: 84, s: "Po", name: "Polonium" },
            { n: 85, s: "At", name: "Astatine" }, { n: 86, s: "Rn", name: "Radon" }, { n: 87, s: "Fr", name: "Francium" }, { n: 88, s: "Ra", name: "Radium" },
            { n: 89, s: "Ac", name: "Actinium" }, { n: 90, s: "Th", name: "Thorium" }, { n: 91, s: "Pa", name: "Protactinium" }, { n: 92, s: "U", name: "Uranium" },
            { n: 93, s: "Np", name: "Neptunium" }, { n: 94, s: "Pu", name: "Plutonium" }, { n: 95, s: "Am", name: "Americium" }, { n: 96, s: "Cm", name: "Curium" },
            { n: 97, s: "Bk", name: "Berkelium" }, { n: 98, s: "Cf", name: "Californium" }, { n: 99, s: "Es", name: "Einsteinium" }, { n: 100, s: "Fm", name: "Fermium" }
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('sketchpad');
            const ctx = canvas.getContext('2d');
            
            // --- Grid System Config ---
            const GRID_SIZE = 40; // Size of each grid cell in pixels
            const ATOM_RADIUS = GRID_SIZE * 0.4; // 40% of the cell size
            const ATOM_COLORS = { 'C': '#333333', 'H': '#CCCCCC', 'O': '#FF0D0D', 'N': '#3050F8', 'DEFAULT': '#888888' };
            
            // --- App State ---
            // Atoms and groups are now stored in GRID coordinates, not pixel coordinates
            let atoms = []; // { id, row, col, element }
            let bonds = []; // { atom1_id, atom2_id }
            let groups = []; // { x, y, w, h } (in grid units)
            
            let activeTool = 'C'; 
            let nextAtomId = 0;

            // --- Mouse/Drag State ---
            let isMouseDown = false;
            let dragStartPos = { row: 0, col: 0 }; // In grid units
            let currentGridPos = { row: 0, col: 0 }; // In grid units
            let tempDragRect = null; // { x, y, w, h } (in grid units)
            let isMouseOnCanvas = false;

            // --- UI Elements ---
            const loadingSpinner = document.getElementById('loading-spinner');
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');
            // Atom Modal
            const atomInfoModal = document.getElementById('atom-info-modal');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const modalFunFactBtn = document.getElementById('modal-fun-fact-btn');
            const modalFunFactText = document.getElementById('modal-fun-fact-text');
            // Group Modal
            const groupInfoModal = document.getElementById('group-info-modal');
            const groupModalCloseBtn = document.getElementById('group-modal-close-btn');
            const modalGroupFormula = document.getElementById('modal-group-formula');
            const modalGroupName = document.getElementById('modal-group-name');
            const modalGroupMass = document.getElementById('modal-group-mass');
            const modalGroupInfoText = document.getElementById('modal-group-info-text');
            const modalGroupInfoBtn = document.getElementById('modal-group-info-btn');

            // --- Canvas Setup ---
            function resizeCanvas() {
                const parent = canvas.parentElement;
                canvas.width = parent.clientWidth;
                canvas.height = parent.clientHeight;
                drawCanvas(); 
            }

            // --- Coordinate Helpers ---
            function getMouseGridPos(evt) {
                const rect = canvas.getBoundingClientRect();
                const clientX = evt.clientX ?? evt.touches[0]?.clientX ?? evt.changedTouches?.[0]?.clientX;
                const clientY = evt.clientY ?? evt.touches[0]?.clientY ?? evt.changedTouches?.[0]?.clientY;
                
                // Pixel position relative to canvas
                const pixelX = clientX - rect.left;
                const pixelY = clientY - rect.top;
                
                // Convert pixel position to grid position
                const col = Math.floor(pixelX / GRID_SIZE);
                const row = Math.floor(pixelY / GRID_SIZE);
                
                return { row, col };
            }

            function gridToPixel(row, col) {
                // Returns the CENTER pixel of a grid cell
                const x = (col * GRID_SIZE) + (GRID_SIZE / 2);
                const y = (row * GRID_SIZE) + (GRID_SIZE / 2);
                return { x, y };
            }

            function getAtomAt(row, col) {
                return atoms.find(a => a.row === row && a.col === col);
            }

            // --- Drawing Functions ---
            function drawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 1. Draw Grid Lines
                ctx.strokeStyle = '#f0f0f0'; // Light gray
                ctx.lineWidth = 1;
                for (let x = 0; x < canvas.width; x += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < canvas.height; y += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                // 2. Draw Groups
                ctx.fillStyle = 'rgba(139, 92, 246, 0.1)'; // purple-500 10%
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.5)'; // purple-500 50%
                ctx.lineWidth = 2;
                groups.forEach(group => {
                    const { x, y, w, h } = normalizeRect(group.x, group.y, group.w, group.h);
                    // Convert grid units to pixels
                    ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, w * GRID_SIZE, h * GRID_SIZE);
                    ctx.strokeRect(x * GRID_SIZE, y * GRID_SIZE, w * GRID_SIZE, h * GRID_SIZE);
                });

                // 3. Draw Bonds
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 4;
                bonds.forEach(bond => {
                    const atom1 = atoms.find(a => a.id === bond.atom1_id);
                    const atom2 = atoms.find(a => a.id === bond.atom2_id);
                    if (atom1 && atom2) {
                        const pos1 = gridToPixel(atom1.row, atom1.col);
                        const pos2 = gridToPixel(atom2.row, atom2.col);
                        ctx.beginPath();
                        ctx.moveTo(pos1.x, pos1.y);
                        ctx.lineTo(pos2.x, pos2.y);
                        ctx.stroke();
                    }
                });

                // 4. Draw Atoms
                atoms.forEach(atom => {
                    const pos = gridToPixel(atom.row, atom.col);
                    const color = ATOM_COLORS[atom.element] || ATOM_COLORS.DEFAULT;
                    
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, ATOM_RADIUS, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    
                    ctx.fillStyle = (color === '#333333' || color === '#3050F8') ? '#FFFFFF' : '#000000';
                    ctx.font = `bold ${ATOM_RADIUS * 0.9}px Inter`; // Scaled font
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(atom.element, pos.x, pos.y);
                });

                // 5. Draw Temporary Drag Box (if dragging)
                if (isMouseDown && tempDragRect) {
                    const { x, y, w, h } = normalizeRect(tempDragRect.x, tempDragRect.y, tempDragRect.w, tempDragRect.h);
                    const isGroupTool = activeTool === 'group';
                    
                    ctx.fillStyle = isGroupTool ? 'rgba(139, 92, 246, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                    ctx.strokeStyle = isGroupTool ? 'rgba(139, 92, 246, 0.8)' : 'rgba(50, 50, 50, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, w * GRID_SIZE, h * GRID_SIZE);
                    ctx.strokeRect(x * GRID_SIZE, y * GRID_SIZE, w * GRID_SIZE, h * GRID_SIZE);
                    ctx.setLineDash([]);
                }
                
                // 6. Draw "Ghost" Cursor
                if (isMouseOnCanvas) {
                    const isAtomTool = !!PERIODIC_TABLE.find(el => el.s === activeTool);
                    const pos = gridToPixel(currentGridPos.row, currentGridPos.col);

                    if (isAtomTool) {
                        // Draw a ghost atom
                        ctx.globalAlpha = 0.5;
                        const color = ATOM_COLORS[activeTool] || ATOM_COLORS.DEFAULT;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, ATOM_RADIUS, 0, 2 * Math.PI);
                        ctx.fillStyle = color;
                        ctx.fill();
                        
                        ctx.fillStyle = (color === '#333333' || color === '#3050F8') ? '#FFFFFF' : '#000000';
                        ctx.font = `bold ${ATOM_RADIUS * 0.9}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(activeTool, pos.x, pos.y);
                        ctx.globalAlpha = 1.0;
                    } else {
                        // Draw a simple box cursor for other tools
                        ctx.strokeStyle = '#333333';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(currentGridPos.col * GRID_SIZE, currentGridPos.row * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
            
            // --- UI Helpers ---
            function setLoading(isLoading) { loadingSpinner.classList.toggle('hidden', !isLoading); }
            function showMessage(text, isError = true) {
                messageText.innerText = text;
                messageBox.classList.toggle('bg-red-500', isError);
                messageBox.classList.toggle('bg-green-500', !isError);
                messageBox.classList.remove('hidden');
                setTimeout(() => { messageBox.classList.add('hidden'); }, 3000);
            }
            function normalizeRect(x, y, w, h) {
                let rx = x, ry = y, rw = w, rh = h;
                if (w < 0) { rx = x + w; rw = -w; }
                if (h < 0) { ry = y + h; rh = -h; }
                return { x: rx, y: ry, w: rw, h: rh };
            }

            // --- Event Handlers (Grid System) ---
            function handleStart(evt) {
                evt.preventDefault();
                isMouseDown = true;
                const { row, col } = getMouseGridPos(evt);
                currentGridPos = { row, col };
                dragStartPos = { row, col };
                
                const isAtomTool = !!PERIODIC_TABLE.find(el => el.s === activeTool);

                if (activeTool === 'info') {
                    // Check for atom first
                    const atom = getAtomAt(row, col);
                    if (atom) {
                        openAtomInfoModal(atom);
                        isMouseDown = false; // Don't start a drag
                        return;
                    }
                    // Check for group
                    const group = getGroupAt(row, col);
                    if (group) {
                        openGroupInfoModal(group);
                        isMouseDown = false;
                        return;
                    }
                    return; // Do nothing if blank space
                }
                
                // Start a drag rectangle
                tempDragRect = { x: col, y: row, w: 1, h: 1 };
                drawCanvas();
            }

            function handleMove(evt) {
                evt.preventDefault();
                const { row, col } = getMouseGridPos(evt);
                currentGridPos = { row, col };
                
                if (isMouseDown) {
                    // Update the temporary drag rectangle
                    tempDragRect.w = (col - dragStartPos.col) + 1;
                    tempDragRect.h = (row - dragStartPos.row) + 1;
                }
                
                drawCanvas();
            }

            function handleEnd(evt) {
                evt.preventDefault();
                if (!isMouseDown) return;
                isMouseDown = false;
                
                const { row, col } = getMouseGridPos(evt);
                const isAtomTool = !!PERIODIC_TABLE.find(el => el.s === activeTool);
                
                if (tempDragRect) {
                    const { x, y, w, h } = normalizeRect(tempDragRect.x, tempDragRect.y, tempDragRect.w, tempDragRect.h);

                    if (isAtomTool) {
                        // --- Fill Atom Logic ---
                        for (let r = y; r < y + h; r++) {
                            for (let c = x; c < x + w; c++) {
                                // Add atom if cell is empty
                                if (!getAtomAt(r, c)) {
                                    atoms.push({
                                        id: nextAtomId++,
                                        row: r,
                                        col: c,
                                        element: activeTool
                                    });
                                }
                            }
                        }
                    } else if (activeTool === 'group') {
                        // --- Add Group Logic ---
                        if (w > 0 && h > 0) { // Only add if it's a valid rect
                            groups.push({ x, y, w, h });
                        }
                    }
                }
                
                tempDragRect = null;
                drawCanvas();
            }
            
            // --- Toolbar Listeners ---
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    if (btn.dataset.atom) {
                        activeTool = btn.dataset.atom;
                    } else if (btn.id === 'tool-info') {
                        activeTool = 'info';
                    } else if (btn.id === 'tool-group') {
                        activeTool = 'group';
                    } else {
                        // Handle predict/clear
                        if (btn.id === 'tool-predict') {
                            callBackendToPredictBonds();
                        } else if (btn.id === 'tool-clear') {
                            atoms = [];
                            bonds = [];
                            groups = [];
                            nextAtomId = 0;
                            drawCanvas();
                        }
                        // De-select action buttons after click
                        setTimeout(() => btn.classList.remove('active'), 100);
                    }
                });
            });

            // --- Search Logic (Unchanged) ---
            function performSearch(query) {
                if (!query) {
                    searchResults.innerHTML = '';
                    searchResults.classList.add('hidden');
                    return;
                }
                const lowerQuery = query.toLowerCase();
                const results = PERIODIC_TABLE.filter(el => 
                    el.name.toLowerCase().includes(lowerQuery) ||
                    el.s.toLowerCase() === lowerQuery ||
                    el.n.toString() === query
                ).slice(0, 10); 

                if (results.length === 0) {
                    searchResults.innerHTML = '<div class="p-3 text-gray-500">No results found</div>';
                } else {
                    searchResults.innerHTML = results.map(el => `
                        <div class="p-3 hover:bg-gray-100 cursor-pointer flex justify-between items-center" data-symbol="${el.s}">
                            <div>
                                <span class="font-bold">${el.s}</span>
                                <span class="text-gray-600 ml-2">${el.name}</span>
                            </div>
                            <span class="text-sm text-gray-400">#${el.n}</span>
                        </div>
                    `).join('');
                }
                searchResults.classList.remove('hidden');
            }
            searchInput.addEventListener('input', (e) => performSearch(e.target.value));
            searchInput.addEventListener('focus', (e) => performSearch(e.target.value));
            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                    searchResults.classList.add('hidden');
                }
            });
            searchResults.addEventListener('click', (e) => {
                const resultItem = e.target.closest('[data-symbol]');
                if (resultItem) {
                    const symbol = resultItem.dataset.symbol;
                    activeTool = symbol;
                    if (!document.getElementById(`tool-${symbol}`)) {
                        const newBtn = document.createElement('button');
                        newBtn.id = `tool-${symbol}`;
                        newBtn.className = 'tool-btn w-full h-16 rounded-lg font-bold text-2xl bg-gray-100 text-gray-800 shadow-md';
                        newBtn.dataset.atom = symbol;
                        newBtn.innerText = symbol;
                        newBtn.addEventListener('click', () => {
                            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                            newBtn.classList.add('active');
                            activeTool = symbol;
                        });
                        const actionsHeader = document.querySelector('h2.text-sm.font-semibold.text-center.text-gray-600:nth-of-type(1)');
                        actionsHeader.parentElement.insertBefore(newBtn, actionsHeader.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling);
                    }
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    document.getElementById(`tool-${symbol}`).classList.add('active');
                    searchInput.value = '';
                    searchResults.classList.add('hidden');
                }
            });

            // --- Atom Info Modal Logic ---
            function openAtomInfoModal(atom) {
                document.getElementById('modal-atom-name').innerText = PERIODIC_TABLE.find(el => el.s === atom.element)?.name || atom.element;
                document.getElementById('modal-atom-id').innerText = atom.id;
                document.getElementById('modal-atom-element').innerText = atom.element;
                document.getElementById('modal-atom-grid').innerText = `Row: ${atom.row}, Col: ${atom.col}`;
                
                const bondCount = bonds.filter(b => b.atom1_id === atom.id || b.atom2_id === atom.id).length;
                document.getElementById('modal-atom-bonds').innerText = bondCount;

                modalFunFactText.innerText = 'Click the button to get a fun fact!';
                modalFunFactBtn.disabled = false;
                modalFunFactBtn.innerText = "Get Fun Fact";
                
                modalFunFactBtn.dataset.element = atom.element;
                atomInfoModal.classList.remove('hidden');
            }
            modalCloseBtn.addEventListener('click', () => atomInfoModal.classList.add('hidden'));
            modalFunFactBtn.addEventListener('click', async (e) => {
                const button = e.target;
                const element = button.dataset.element;
                
                button.disabled = true;
                button.innerText = "Loading...";
                
                try {
                    const response = await fetch('./api/get_fun_fact', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ element })
                    });
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.error || 'Failed to fetch fact');
                    }
                    const data = await response.json();
                    modalFunFactText.innerText = data.fact;
                    button.innerText = "Fact Loaded!";
                } catch (error) {
                    console.error("Fun fact error:", error);
                    modalFunFactText.innerText = "Sorry, I couldn't get a fact right now.";
                    button.disabled = false; 
                    button.innerText = "Try Again";
                }
            });

            // --- Group Info Modal Logic ---
            function getGroupAt(row, col) {
                // Find in reverse so we get the top-most group
                for (let i = groups.length - 1; i >= 0; i--) {
                    const group = groups[i];
                    const { x, y, w, h } = normalizeRect(group.x, group.y, group.w, group.h);
                    // Check if click is inside the group box (grid units)
                    if (col >= x && col < x + w && row >= y && row < y + h) {
                        return group; // Return the group object
                    }
                }
                return null; // No group found
            }

            function calculateFormula(atomList) {
                if (atomList.length === 0) return "N/A";
                
                const counts = atomList.reduce((acc, element) => {
                    acc[element] = (acc[element] || 0) + 1;
                    return acc;
                }, {});

                // Format: C, then H, then alphabetical
                let formula = "";
                if (counts.C) {
                    formula += `C${counts.C > 1 ? counts.C : ''}`;
                    delete counts.C;
                }
                if (counts.H) {
                    formula += `H${counts.H > 1 ? counts.H : ''}`;
                    delete counts.H;
                }
                
                Object.keys(counts).sort().forEach(element => {
                    formula += `${element}${counts[element] > 1 ? counts[element] : ''}`;
                });
                
                return formula;
            }

            function getAtomsInGroup(group) {
                const { x, y, w, h } = normalizeRect(group.x, group.y, group.w, group.h);
                return atoms.filter(atom => 
                    atom.col >= x && atom.col < x + w &&
                    atom.row >= y && atom.row < y + h
                );
            }

            function openGroupInfoModal(group) {
                const atomsInGroup = getAtomsInGroup(group);
                const atomList = atomsInGroup.map(atom => atom.element);
                
                modalGroupFormula.innerText = calculateFormula(atomList);
                modalGroupName.innerText = "N/A";
                modalGroupMass.innerText = "N/A";
                modalGroupInfoText.innerText = "Click the button to get AI-powered info.";
                
                modalGroupInfoBtn.disabled = false;
                modalGroupInfoBtn.innerText = "Get AI Info (Name, Mass)";
                modalGroupInfoBtn.dataset.atoms = JSON.stringify(atomList);
                
                groupInfoModal.classList.remove('hidden');
            }

            groupModalCloseBtn.addEventListener('click', () => groupInfoModal.classList.add('hidden'));

            modalGroupInfoBtn.addEventListener('click', async (e) => {
                const button = e.target;
                const atomList = JSON.parse(button.dataset.atoms);

                if (atomList.length === 0) {
                    modalGroupInfoText.innerText = "No atoms in this group to analyze.";
                    return;
                }
                
                button.disabled = true;
                button.innerText = "Loading AI Info...";
                modalGroupInfoText.innerText = "Contacting AI chemist...";

                try {
                    const response = await fetch('./api/get_molecule_info', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ atoms: atomList })
                    });

                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.error || 'Failed to fetch info');
                    }
                    
                    const data = await response.json();
                    
                    modalGroupName.innerText = data.common_name;
                    modalGroupMass.innerText = `${data.molar_mass_g_mol} g/mol`;
                    modalGroupInfoText.innerText = "AI analysis complete!";
                    button.innerText = "Info Loaded!";

                } catch (error) {
                    console.error("Molecule info error:", error);
                    modalGroupInfoText.innerText = `Error: ${error.message}`;
                    button.disabled = false;
                    button.innerText = "Try Again";
                }
            });

            // --- Backend Prediction Logic (Grid System) ---
            const BACKEND_URL = "./api/predict_bonds";

            async function callBackendToPredictBonds() {
                // 1. Clear all existing bonds
                bonds = [];
                setLoading(true);

                if (groups.length === 0) {
                    showMessage("You must draw a group box (purple) around atoms to predict bonds.");
                    setLoading(false);
                    return;
                }

                let predictionRequests = [];

                groups.forEach(group => {
                    const atomsInGroup = getAtomsInGroup(group);
                    
                    if (atomsInGroup.length >= 2) {
                        const atomList = atomsInGroup.map(atom => atom.element);
                        const atomIdMap = atomsInGroup.map(atom => atom.id); // Map local index -> global ID
                        predictionRequests.push(runPrediction(atomList, atomIdMap));
                    }
                });

                if (predictionRequests.length === 0) {
                    showMessage("No groups found containing 2 or more atoms.");
                    setLoading(false);
                    return;
                }

                try {
                    await Promise.all(predictionRequests);
                    showMessage("Bonds predicted!", false);
                } catch (error) {
                    console.error("Backend Prediction Error:", error);
                    showMessage("One or more predictions failed: " + error.message);
                } finally {
                    setLoading(false);
                    drawCanvas();
                }
            }
            
            async function runPrediction(atomList, atomIdMap) {
                const payload = { atoms: atomList };
                
                const response = await fetch(BACKEND_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || `HTTP error! status: ${response.status}`);
                }
                
                const prediction = await response.json();
                applyPredictions(prediction, atomIdMap);
            }

            function applyPredictions(prediction, atomIdMap) {
                if (!prediction.bonds) return;

                prediction.bonds.forEach(bond => {
                    const local_idx_1 = bond.from;
                    const local_idx_2 = bond.to;
                    const id1 = atomIdMap[local_idx_1];
                    const id2 = atomIdMap[local_idx_2];
                    
                    if (id1 !== undefined && id2 !== undefined) {
                        const bondExists = bonds.some(b => (b.atom1_id === id1 && b.atom2_id === id2) || (b.atom1_id === id2 && b.atom2_id === id1));
                        if (!bondExists) {
                            bonds.push({ atom1_id: id1, atom2_id: id2, type: bond.type || "SINGLE" });
                        }
                    }
                });
            }

            // --- Canvas Event Listeners ---
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('mouseleave', () => {
                isMouseOnCanvas = false;
                if (isMouseDown) { // Treat as a mouseup
                    handleEnd(new MouseEvent('mouseup'));
                }
                drawCanvas();
            });
            canvas.addEventListener('mouseenter', () => {
                isMouseOnCanvas = true;
                drawCanvas();
            });
            
            // Touch events mapped to grid logic
            canvas.addEventListener('touchstart', (e) => {
                isMouseOnCanvas = true;
                handleStart(e);
            });
            canvas.addEventListener('touchmove', (e) => {
                isMouseOnCanvas = true;
                handleMove(e);
            });
            canvas.addEventListener('touchend', (e) => {
                isMouseOnCanvas = false;
                handleEnd(e);
            });
            canvas.addEventListener('touchcancel', (e) => {
                isMouseOnCanvas = false;
                handleEnd(e);
                isMouseDown = false;
            });

            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // --- Initial Load ---
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        });
    </script>
</body>
</html>